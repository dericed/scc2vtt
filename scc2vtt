#!/usr/bin/env python3

import sys

blank=''

vtt_header= 'WEBVTT\n\n'

char2code = {'':'91b9','’':'9229','Ø':'13ba','©':'92ab','Ì':'1323','ô':'913e',
		'¢':'91b5','õ':'13a8','Ç':'9232','¦':'13ae','{':'1329','Ó':'92a2',
		'Ò':'1325','\\':'13ab','ø':'133b','“':'92ae','Ë':'92b5','|':'1337',
		'Õ':'13a7','┘':'13bf','Ô':'92ba','Ê':'9234','Ú':'9223','ö':'13b3',
		'Î':'9237','ì':'13a4','£':'91b6','ä':'1331','”':'922f','¿':'91b3',
		'Ö':'1332','┐':'133d','à':'9138','Å':'1338','«':'923e','î':'913d',
		'Ü':'92a4','Ï':'9238','™':'9134','ò':'1326','Ã':'1320','ï':'92b9',
		'*':'92a8','_':'13ad','Û':'923d','À':'92b0','â':'913b','┌':'13bc',
		'ã':'13a1','¡':'92a7','®':'91b0','•':'92ad','ê':'91bc','~':'132f',
		'ü':'9225','Ù':'923b','Ä':'13b0','ß':'1334','ù':'92bc','└':'133e',
		'½':'9132','È':'92b3','É':'92a1','ë':'92b6','¥':'13b5','^':'132c',
		'}':'132a','¤':'13b6','—':'922a','»':'92bf','Â':'9231','å':'13b9',
		'°':'9131','‘':'9226','♪':'9137','℠':'922c','Á':'9220','è':'91ba',
		'Í':'13a2','û':'91bf'}



# I drop these codes ....for now?
drops=('9170','94ae','94ad','9420', '942c','9425','9426','97a1')

chars=list(char2code.keys())
codes=list(char2code.values())

def scc2char(hexed):
#    if hexed == '80':	return '\n'
    s='0x'+hexed
    i=int(s,16)
    if i in [80,128,138]:
        return "\n"

    if hexed[0] in ['a','b','c','d','e','f']: i= i ^ 0x80
    #i = i ^ 0x80
    return chr(i)

def scc_time2vtt(line_time):
	lt=line_time.replace(":",".")
	lt=lt.replace(".",":",2)
	return lt

def clear_drops(chunk):
	'''
	drop the drops
	'''
	if chunk in drops: chunk= blank
	return chunk

def scc_chunk2char(chunk):
	'''
	take an scc chunk like '92ad'and see if it is listed in
	the specials or extended codes tuples return decoded value from a chars tuple
	'''
	decoded=blank

	if chunk in codes:
		idx=codes.index(chunk)
		decoded=chars[idx]
	return decoded

def scc_chunk2twochars(chunk):
	'''
	decode scc into chaars
	'''
	decoded=blank
	chunk=chunk.lower()
	if chunk.startswith('9') or chunk.startswith('1'):
		decoded=scc_chunk2char(chunk)
	else:
		one,two=chunk[:2],chunk[2:]
		try:
			decoded=scc2char(one)
			decoded +=scc2char(two)
		except:
			decoded="%s%s"%(one,two)
	return decoded


def scc_dechunk(chunked):
	'''
	split captions into chunks,and decode everything
	'''
	buffed=[]
	chunks=chunked.split(' ')
	for chunk in chunks:
		chunk=clear_drops(chunk)
		if chunk is not blank:
			decoded=scc_chunk2twochars(chunk)
			buffed.append(decoded)
	return  buffed

def scc_split(scc_file):
	'''
	times and captions are separated by a tab,
	'''
	scc_input=scc_file.readlines()
	scc_times=[]
	scc_caps=[]
	for line in scc_input:
		if '\t' in line:
			sl=line.split('\t')
			dechunked=scc_dechunk(sl[1])
			if len(dechunked) > 1:
				scc_times.append(sl[0])
				scc_caps.append(dechunked)
	return scc_times,scc_caps

def as_vtt(start,stop,text):
	vtt_data = ['%(start)s --> %(stop)s ' %{ 'start':start, 'stop': stop},
	'%(text)s \n\n' %{'text':text}]
	return '\n'.join(vtt_data)

def scc_decoder(scc_file):
	scc_times,scc_caps=scc_split(scc_file)
	vtt=[vtt_header]
	for i in range (len(scc_caps)):
		start=scc_time2vtt(scc_times[i])
		try: stop=scc_time2vtt(scc_times[i+1])
		except: stop="00:00:00.000"
		text=''.join(scc_caps[i])
		vtt.append(as_vtt(start,stop,text))
	return ''.join(vtt)


if __name__=='__main__':
	if len(sys.argv) > 1:
		with open(sys.argv[1]) as scc_file:
			with open("out.vtt",'w+') as outfile:
				outfile.write(scc_decoder(scc_file))

